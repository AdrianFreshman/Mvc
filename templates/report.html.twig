{% extends "base.html.twig" %}

{% block title %}About{% endblock %}

{% block body %}
    <h1>Reports</h1>
    <h4 id="kmom01">Kmom01</h4>
    <p>Jag har erfarenhet endast genom oopython-kursen där vi skapade klasser och moduler, vilket var knepigt men roligt.

PHPs modell för klasser och objekt är baserad på koncepten i objektorienterad programmering, som inkluderar klasser, objekt, egenskaper och metoder. För att skapa dina första klasser i PHP behöver du förstå grundläggande begrepp som objekt, instansiering, egenskaper och metoder. <br><br>

Uppgiften me/report använde en kodstruktur som byggde på Symfony-ramverket och använde JavaScript-rutter och Twig-filer. Jag uppfattade den som välstrukturerad och lätt att följa.<br><br>

När det gäller artikeln “PHP The Right Way” är de delar som jag finner extra intressanta och värdefulla de som handlar om kodstil och programmeringsparadigmer, särskilt objektorienterad programmering och funktionell programmering. Jag vill lära mig mer om hur man kan använda funktioner som variabler och högre ordningens funktioner i PHP. De delar av artikeln som jag finner mest värdefulla är de som förklarar PSR-standarden för kodstil och hur man kan använda verktyg som PHP_CodeSniffer för att följa denna standard, samt länkar till andra resurser som Clean Code PHP.<br><br>Xdebug
En av de mest användbara verktygen inom mjukvaruutveckling är en ordentlig felsökare. Det låter dig spåra utförandet av din kod och övervaka innehållet i stacken. Xdebug, PHP:s felsökare, kan användas av olika IDE:er för att tillhandahålla brytpunkter och stackinspektion. Det kan också tillåta verktyg som PHPUnit och KCacheGrind att utföra kodtäckningsanalys och kodprofilering.<br><br>

Om du finner dig själv i en knipa, villig att ta till var_dump()/print_r(), och du fortfarande inte kan hitta lösningen - kanske behöver du använda felsökaren.<br><br>

Idag fick jag veta att det finns ett växande intresse för att använda Symfony-ramverket, JavaScript och nya CSS-ramverk i webbutveckling. Dessa tekniker blir allt mer populära på grund av deras förmåga att förenkla utvecklingsprocessen, öka produktiviteten och förbättra användarupplevelsen.<br><br>

Symfony är ett PHP-webbapplikationsramverk som tillhandahåller en standardiserad uppsättning verktyg och bästa praxis för att bygga webbapplikationer. Det är känt för sin modulära arkitektur, som gör det möjligt för utvecklare att bygga applikationer med hjälp av återanvändbara komponenter. Detta kan hjälpa till att minska utvecklingstiden och förbättra kodkvaliteten.<br><br>


TIL: att det finns ett växande intresse för att använda Symfony-ramverket, JavaScript och nya CSS-ramverk i webbutveckling. Dessa tekniker blir allt mer populära på grund av deras förmåga att förenkla utvecklingsprocessen, öka produktiviteten och förbättra användarupplevelsen</p>

<h4>Kmom02</h4


<p> Arv, komposition, interface och trait är alla objektorienterade konstruktioner som används i PHP för att strukturera och organisera kod.

Arv innebär att en klass kan ärva egenskaper och metoder från en annan klass. Komposition innebär att en klass kan innehålla en annan klass som en del av sin struktur. Interface definierar en uppsättning metoder som måste implementeras av en klass som implementerar gränssnittet. Trait tillhandahåller återanvändbara bitar av kod som kan användas av flera klasser.<br><br>

Arv kan vara fördelaktigt eftersom det möjliggör återanvändning av kod genom att en klass kan ta egenskaper och metoder från en befintlig klass och sedan lägga till eller modifiera dem. Detta minskar också kodupprepning och gör det enklare att underhålla koden.<br><br>

Komposition kan användas för att konstruera mer komplexa objekt genom att kombinera flera mindre objekt. Detta gör koden mer flexibel och lättare att ändra eftersom de mindre objekten kan bytas ut eller modifieras utan att påverka hela strukturen.<br><br>

Interface ger en standardiserad uppsättning av metoder som en klass måste implementera, vilket kan göra det lättare att byta ut en klass mot en annan som implementerar samma gränssnitt. Detta ökar också kodenhet och kan göra koden enklare att testa.<br><br>

Trait tillåter återanvändning av kod, särskilt kod som inte passar in i en hierarki av arv eller som används i flera olika klasser. Detta kan minska kodupprepning och göra koden mer lättunderhållen.<br><br>

Sammanfattningsvis kan användningen av objektorienterade konstruktioner såsom arv, komposition, interface och trait göra koden mer lättunderhållen, flexibel och lättare att ändra. Det kan också öka kodenhet och minska kodupprepning.<br><br>

I min implementation av kortspelet i uppgiften använde jag arv och komposition för att skapa en hierarki av klasser som representerade olika delar av spelet. Jag är ganska nöjd med min lösning, men jag tror att det finns utrymme för förbättringar i koden genom att skapa fler abstrakta klasser och gränssnitt, det var en del att ha att fixa med till build och compeser fixern,samt stoppa in en ny controller och annat, paths, api osv, men det det gick tillslut!<br><br>

Att modellera kortspelet med flödesdiagram och pseudokod var mycket hjälpsamt för att strukturera min kod. Det hjälpte mig att visualisera hur olika delar av spelet samverkar och identifiera eventuella problemområden som jag behövde ta hänsyn till i min kod. Men ananrs verkar jag nog ha missat en del steg i hur det ska fungera, använde mig av uml som jag använde till oopython<br><br>

Min TIL för detta kmom är hur man använder objektorienterade konstruktioner som arv, komposition, interface och trait i PHP för att skapa modulär och återanvändbar kod.</p>
<h4>Kmom03</h4
<p> Se till att följande frågor besvaras i din redovisningstext.

Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?
<br><br>

Det var intressant att skapa flödesdiagram och pseudokod för blackjack-spelet eftersom det gav en bättre överblick över hur spelet fungerade och vilka steg som krävdes för att spela det. Även om det fanns andra tester innan vi började med flödesdiagrammet och pseudokoden, så var det en annan nivå av strukturering som gjorde det enklare att se spelet som regler och steg istället för en röra av kod.
<br><br>
Det blevenklare att planera koden och hitta eventuella fel innan jag börjar skriva själva koden. Dessutom blvr det enklare att kommunicera med andra om koden eftersom man har en gemensam förståelse av hur spelet fungerar.
<br><br>
Att modellera ett kortspel med flödesdiagram och pseudokod kändes som en utmaning eftersom det krävdes att tänka på många olika scenarier och steg som ingår i spelet. Men samtidigt var det en lärorik process som gav en bättre förståelse för hur man kan strukturera kod kring en applikation.
<br><br>
Jag tror definitivt att det stödjer mig i min problemlösning och tankearbete. Genom att bryta ner problemet i mindre delar och visualisera dem, blir det enklare att tänka på alla scenarier som behöver hanteras. Det blir också lättare att se mönster och undvika onödig repetition av kod.
<br><br>
Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?
<br><br>
Spelet är byggt med flera klasser som samverkar för att skapa en fungerande applikation.
<br><br>
En viktig klass är BlackjackGame som är en kontrollklass som håller koll på spelets logik och status. Klassen innehåller också andra klasser som Deck och ScoreCalculator som hanterar kortleken och poängräkning.
<br><br>
En annan klass är ScoreCalculator som används för att beräkna poängen för en spelares kort. Den här klassen loopar igenom korten och adderar poängen. Klassen hanterar också essen på ett särskilt sätt för att undvika att spelare får för höga poäng.
<br><br>
Jag skapade 30% av ett Texas hold'em-spel tidigare, men jag insåg att det skulle kräva mycket tid och många klasser att skapa en komplett applikation. Därför bestämde jag mig för att skapa en enklare version av blackjack istället. Trots att jag bara skapade en enklare version av spelet är jag ganska nöjd med det jag åstadkommit. Jag lyckades skapa en fungerande version av spelet med lite rolig CSS.
<br><br>
Det finns alltid förbättringspotential när det gäller kod, och jag kan se en del saker jag skulle vilja förbättra. Till exempel skulle jag vilja lägga till fler funktioner, som att kunna satsa flera gånger per runda, och att skapa en bättre hantering av vinst- och förlustsituationer, dubbla och halvera och andra extra regler samt vinst statestik kring hand. Det skulle också vara kul att förbättra spelets grafiska utseende. Men överlag är jag ganska nöjd med min implementation och tycker att den fungerar bra som en enkel version av blackjack-spelet.
<br><br>
Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?
<br><br>
Jag trivs väldigt bra med att koda i Symfony, det är ett väldigt robust och flexibelt ramverk som gör det lätt att skapa avancerade webbapplikationer. Gillar start den inbyggda felhanteringen och att jag upplever det flexibelt.Efter att ha arbetat med Symfony ett tag har jag upptäckt att det finns många smarta verktyg och funktioner som kan underlätta arbetet och göra koden mer läsbar och strukturerad.
<br><br>
Vilken är din TIL för detta kmom?</p>
<br><br>

Under detta kursmoment har jag lärt mig hur man kan skapa objektorienterade lösningar och använder klasser för att organisera kod och funktioner. Det är viktigt att tänka på objektorientering för att skriva ren, modulär och återanvändbar kod. Klasserna kan användas för att gruppera relaterade funktioner och data, och det blir lättare att lägga till och ändra funktionalitet.
<br><br>
För att skapa kluriga klasser kan man tänka på att följa SOLID-principerna, särskilt öppen-stängd-principen (Open-Closed Principle) som betyder att en klass ska vara öppen för utökning men stängd för ändring. Detta innebär att man inte ska behöva ändra en klass för att lägga till funktionalitet, utan istället utöka den med en ny klass eller funktion som bygger vidare på den ursprungliga klassen.
<br><br>
För att skapa egen error hantering kan man använda verktyg som PHPStan som kan analysera koden för att hitta potentiella fel och problem. Man kan också skapa egna undantag (exceptions) som ger mer detaljerade felmeddelanden än de vanliga PHP-felen. Detta gör det enklare att felsöka och förbättra koden. Genom att skapa egna undantag kan man också bättre hantera fel som kan uppstå i en större applikation eller ramverk.Dock lekte jag inte mycket med detta

    <h4>Kmom04</h4

    <p>
    PHPUnit är en välkänd och respekterad PHP-testram som gör det möjligt för mig att testa min kod för att säkerställa att den fungerar korrekt. Några av fördelarna med att använda PHPUnit inkluderar att det hjälper mig att hitta buggar och problem i koden, ökar kvaliteten på koden och gör det lättare att underhålla och utveckla koden på lång sikt. Jag gillade hur det ser ut i mitt docs/coverage och kan enkelt hitta fel och det ser snyggt ut somsagt.
    </p>
    <br><br>

    <p>
    Fick till 75-80% vilken kan tyckas vara en ok start, men att ha en högre kodtäckning är alltid att föredra såklart. Det kan vara svårt att testa privata och skyddade funktioner vilket jag märkte samt saknade funktioner som kunde ta ut specifika fall eftersom jag använde min shuffle till korten osv,detta ledde till att jag inte kunde utan att fixa om/stoppa in flera funktioner(fick problem kring komplexitet i composer lint), fixen hade kunnat vara att fixa i card och eller blakjack en klass som hanterar att manuellt kunna skriva in kort en vill ha, detta kunde testa tie() samt annat som saknades till att nå 90% just nu avgör slumpen om tie() kommer triggas i min testning, men iaf , det är fortfarande möjligt att testa dem genom att använda reflektion och andra tekniker. 
    </p>
    <br><br>

    <p>
     Min kod var tillräckligt testbar men finns brister..
     De faktorer som  påverkade koden som testbar eller inte: Min kod är för stor och komplicerad kan det vara svårt att testa allt. Det kan också finnas svårigheter med att testa en kod som har många beroenden eller som är beroende av externa faktorer. För att förbättra min kods testbarhet kunde jag ha skapat mer lättförståelig kod genom att skapa tydligare kaller med en enda ansvarsområde, följa SOLID-principerna och undvika hårdkodade värden osv samt se ovan.
    </p>
    <br><br>
    <p>
    Har tankar till att skriva till bryta ut klassen BlackjackGame och och fixa det lite mer tydligare, Har somsagt velat fixa en specefic deal(valt kort) funktion men kommer aldrig dit, hade underlättat testningen, dock kan jag se att det hade fungerat vid testning om jag endast hade haft den.
    </p>
    <p>
    En vältestad kod är oftast ren och snygg. När du skriver enhetstester tvingas du att tänka på ditt kodkontrakt och hur dina metoder bör fungera. Detta leder till en mer organiserad kod som är lättare att underhålla och utveckla på lång sikt.
     </p>
    <br><br>
    <p> Min TIL (Today I Learned) för detta kmom är att enhetstester och testdriven utveckling kan hjälpa till att förbättra kvaliteten på din kod och göra den lättare att underhålla och utveckla på lång sikt. Det är också viktigt att prioritera kodtäckning och att skapa testbar kod för att uppnå detta.
    </p>

    <h4>Kmom05</h4
    <br><br>
    <h4>Gick det bra att jobba igenom övningen med Symfony och Doctrine? Något särskilt du tänkte/reagerade på under övningen?</h4>
    <br><br>
    <p>Ja, det gick bra att jobba igenom övningen med Symfony och Doctrine. En sak som jag märkte var att Symfony och Doctrine är kraftfulla verktyg som underlättar utvecklingen av webbapplikationer. De erbjuder många inbyggda funktioner och hjälper till att hantera olika aspekter av applikationen, inklusive databasåtkomst och modellhantering. Dessutom ger de en strukturerad och organiserad arbetsmetod genom att följa MVC-arkitekturmönstret. Jag gillar verkligen hur enkelt det var att skapa en struktur från scratch. Hur Doctrine skapade en bra "mall" mot webben.</p>
    <br><br>
    <h4>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?</h4>
    <br><br>
    <p>Under övningen byggde jag en enkel webbapplikation i min controller för att hantera böcker. Applikationen tillät användare att lägga till, visa, uppdatera och ta bort böcker från en databas. 
    När det gäller användargränssnittet valde jag att använda standard html/css men som jag tyckte slutade men en snygg look och enkelt att se och första. Jag använde även Twig-templatemotorn för att rendera vyer och skapa enkla användargränssnittskomponenter. Jag ville ha en ren och minimalistisk design för att fokusera på funktionaliteten snarare än det visuella.</p>
    <br><br>
    <h4>Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?</h4>
    <br><br>
    <p>Ja, det gick bra att jobba med ORM (Object-Relational Mapping) i CRUD-operationerna. Doctrine ORM gjorde det enkelt att arbeta med databasåtkomst genom att använda objekt istället för att skriva råa SQL-querys. Detta minskade komplexiteten och gjorde kodbasen mer läsbar och underhållbar.
    Jämfört med att arbeta med råa SQL-querys eller enklare databasabstraktioner, som till exempel PDO (PHP Data Objects), ger ORM en mer abstrakt och objektorienterad metod för att interagera med databasen. Det gör det enklare att hantera relationer mellan olika tabeller och erbjuder kraftfulla funktioner som till exempel datavalidering och automatisk generering av SQL-frågor.</p>
    <h4>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</h4>
    <br><br>
    <p>Min uppfattning om ORM är övervägande positiv. ORM-verktyg som Doctrine erbjuder en högre nivå av abstraktion och underlättar hanteringen av databasrelaterade uppgifter. Genom att använda ORM kan jag arbeta med databasen på ett objektorienterat sätt och undvika att behöva skriva råa SQL-frågor. Detta gör koden mer läsbar, underhållbar och minimerar risken för SQL-injektion.
    <br><br>
    Jämfört med att arbeta med råa SQL-frågor eller enklare databasabstraktioner som PDO/databaskursen, erbjuder ORM en rad fördelar. Det ger möjlighet att definiera och hantera relationer mellan tabeller på ett tydligt och enkelt sätt genom att använda objektorienterade koncept som associationer och navigering mellan entiteter. Det ger även möjlighet att använda datavalidering, automatisk generering av SQL-frågor och möjlighet till migrationshantering för att hantera databasförändringar över tiden.
    <br><br>
    En annan fördel med ORM är att det gör det enklare att byta databasbackend. Genom att använda en abstraktionsnivå kan man skriva applikationskod som är oberoende av den specifika databasen. Detta gör det möjligt att migrera applikationen till en annan databas utan att behöva ändra i själva koden.
    <br><br>
    Sammanfattningsvis är ORM ett kraftfullt verktyg för att hantera databasrelaterade uppgifter i applikationer. Det erbjuder en högre nivå av abstraktion, förenklar utvecklingen och minskar risken för vanliga problem som SQL-injektion. Det är dock viktigt att förstå hur ORM fungerar under huven och vara medveten om dess prestanda- och skalbarhetsaspekter i förhållande till specifika användningsfall.</p>
    <br><br>
    <h4>Vilken är din TIL för detta kmom?</h4>
    <p>Jag har även fått en introduktion till Doctrine ORM och dess förmåga att hantera databasrelaterade uppgifter på ett objektorienterat sätt. Genom att definiera entiteter och relationer kan man använda Doctrine för att kommunicera med databasen och utföra CRUD-operationer.</p>
    <h4>Kmom06</h4
    <p></p>

{% endblock %}