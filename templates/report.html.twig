{% extends "base.html.twig" %}

{% block title %}About{% endblock %}

{% block body %}
    <h1>Reports</h1>
    <h4 id="kmom01">Kmom01</h4>
    <p>Jag har erfarenhet endast genom oopython-kursen där vi skapade klasser och moduler, vilket var knepigt men roligt.

PHPs modell för klasser och objekt är baserad på koncepten i objektorienterad programmering, som inkluderar klasser, objekt, egenskaper och metoder. För att skapa dina första klasser i PHP behöver du förstå grundläggande begrepp som objekt, instansiering, egenskaper och metoder. <br><br>

Uppgiften me/report använde en kodstruktur som byggde på Symfony-ramverket och använde JavaScript-rutter och Twig-filer. Jag uppfattade den som välstrukturerad och lätt att följa.<br><br>

När det gäller artikeln “PHP The Right Way” är de delar som jag finner extra intressanta och värdefulla de som handlar om kodstil och programmeringsparadigmer, särskilt objektorienterad programmering och funktionell programmering. Jag vill lära mig mer om hur man kan använda funktioner som variabler och högre ordningens funktioner i PHP. De delar av artikeln som jag finner mest värdefulla är de som förklarar PSR-standarden för kodstil och hur man kan använda verktyg som PHP_CodeSniffer för att följa denna standard, samt länkar till andra resurser som Clean Code PHP.<br><br>Xdebug
En av de mest användbara verktygen inom mjukvaruutveckling är en ordentlig felsökare. Det låter dig spåra utförandet av din kod och övervaka innehållet i stacken. Xdebug, PHP:s felsökare, kan användas av olika IDE:er för att tillhandahålla brytpunkter och stackinspektion. Det kan också tillåta verktyg som PHPUnit och KCacheGrind att utföra kodtäckningsanalys och kodprofilering.<br><br>

Om du finner dig själv i en knipa, villig att ta till var_dump()/print_r(), och du fortfarande inte kan hitta lösningen - kanske behöver du använda felsökaren.<br><br>

Idag fick jag veta att det finns ett växande intresse för att använda Symfony-ramverket, JavaScript och nya CSS-ramverk i webbutveckling. Dessa tekniker blir allt mer populära på grund av deras förmåga att förenkla utvecklingsprocessen, öka produktiviteten och förbättra användarupplevelsen.<br><br>

Symfony är ett PHP-webbapplikationsramverk som tillhandahåller en standardiserad uppsättning verktyg och bästa praxis för att bygga webbapplikationer. Det är känt för sin modulära arkitektur, som gör det möjligt för utvecklare att bygga applikationer med hjälp av återanvändbara komponenter. Detta kan hjälpa till att minska utvecklingstiden och förbättra kodkvaliteten.<br><br>


TIL: att det finns ett växande intresse för att använda Symfony-ramverket, JavaScript och nya CSS-ramverk i webbutveckling. Dessa tekniker blir allt mer populära på grund av deras förmåga att förenkla utvecklingsprocessen, öka produktiviteten och förbättra användarupplevelsen</p>

<h4>Kmom02</h4


<p> Arv, komposition, interface och trait är alla objektorienterade konstruktioner som används i PHP för att strukturera och organisera kod.

Arv innebär att en klass kan ärva egenskaper och metoder från en annan klass. Komposition innebär att en klass kan innehålla en annan klass som en del av sin struktur. Interface definierar en uppsättning metoder som måste implementeras av en klass som implementerar gränssnittet. Trait tillhandahåller återanvändbara bitar av kod som kan användas av flera klasser.<br><br>

Arv kan vara fördelaktigt eftersom det möjliggör återanvändning av kod genom att en klass kan ta egenskaper och metoder från en befintlig klass och sedan lägga till eller modifiera dem. Detta minskar också kodupprepning och gör det enklare att underhålla koden.<br><br>

Komposition kan användas för att konstruera mer komplexa objekt genom att kombinera flera mindre objekt. Detta gör koden mer flexibel och lättare att ändra eftersom de mindre objekten kan bytas ut eller modifieras utan att påverka hela strukturen.<br><br>

Interface ger en standardiserad uppsättning av metoder som en klass måste implementera, vilket kan göra det lättare att byta ut en klass mot en annan som implementerar samma gränssnitt. Detta ökar också kodenhet och kan göra koden enklare att testa.<br><br>

Trait tillåter återanvändning av kod, särskilt kod som inte passar in i en hierarki av arv eller som används i flera olika klasser. Detta kan minska kodupprepning och göra koden mer lättunderhållen.<br><br>

Sammanfattningsvis kan användningen av objektorienterade konstruktioner såsom arv, komposition, interface och trait göra koden mer lättunderhållen, flexibel och lättare att ändra. Det kan också öka kodenhet och minska kodupprepning.<br><br>

I min implementation av kortspelet i uppgiften använde jag arv och komposition för att skapa en hierarki av klasser som representerade olika delar av spelet. Jag är ganska nöjd med min lösning, men jag tror att det finns utrymme för förbättringar i koden genom att skapa fler abstrakta klasser och gränssnitt, det var en del att ha att fixa med till build och compeser fixern,samt stoppa in en ny controller och annat, paths, api osv, men det det gick tillslut!<br><br>

Att modellera kortspelet med flödesdiagram och pseudokod var mycket hjälpsamt för att strukturera min kod. Det hjälpte mig att visualisera hur olika delar av spelet samverkar och identifiera eventuella problemområden som jag behövde ta hänsyn till i min kod. Men ananrs verkar jag nog ha missat en del steg i hur det ska fungera, använde mig av uml som jag använde till oopython<br><br>

Min TIL för detta kmom är hur man använder objektorienterade konstruktioner som arv, komposition, interface och trait i PHP för att skapa modulär och återanvändbar kod.</p>
<h4>Kmom03</h4
<p> Se till att följande frågor besvaras i din redovisningstext.

Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?
<br><br>

Det var intressant att skapa flödesdiagram och pseudokod för blackjack-spelet eftersom det gav en bättre överblick över hur spelet fungerade och vilka steg som krävdes för att spela det. Även om det fanns andra tester innan vi började med flödesdiagrammet och pseudokoden, så var det en annan nivå av strukturering som gjorde det enklare att se spelet som regler och steg istället för en röra av kod.
<br><br>
Det blevenklare att planera koden och hitta eventuella fel innan jag börjar skriva själva koden. Dessutom blvr det enklare att kommunicera med andra om koden eftersom man har en gemensam förståelse av hur spelet fungerar.
<br><br>
Att modellera ett kortspel med flödesdiagram och pseudokod kändes som en utmaning eftersom det krävdes att tänka på många olika scenarier och steg som ingår i spelet. Men samtidigt var det en lärorik process som gav en bättre förståelse för hur man kan strukturera kod kring en applikation.
<br><br>
Jag tror definitivt att det stödjer mig i min problemlösning och tankearbete. Genom att bryta ner problemet i mindre delar och visualisera dem, blir det enklare att tänka på alla scenarier som behöver hanteras. Det blir också lättare att se mönster och undvika onödig repetition av kod.
<br><br>
Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?
<br><br>
Spelet är byggt med flera klasser som samverkar för att skapa en fungerande applikation.
<br><br>
En viktig klass är BlackjackGame som är en kontrollklass som håller koll på spelets logik och status. Klassen innehåller också andra klasser som Deck och ScoreCalculator som hanterar kortleken och poängräkning.
<br><br>
En annan klass är ScoreCalculator som används för att beräkna poängen för en spelares kort. Den här klassen loopar igenom korten och adderar poängen. Klassen hanterar också essen på ett särskilt sätt för att undvika att spelare får för höga poäng.
<br><br>
Jag skapade 30% av ett Texas hold'em-spel tidigare, men jag insåg att det skulle kräva mycket tid och många klasser att skapa en komplett applikation. Därför bestämde jag mig för att skapa en enklare version av blackjack istället. Trots att jag bara skapade en enklare version av spelet är jag ganska nöjd med det jag åstadkommit. Jag lyckades skapa en fungerande version av spelet med lite rolig CSS.
<br><br>
Det finns alltid förbättringspotential när det gäller kod, och jag kan se en del saker jag skulle vilja förbättra. Till exempel skulle jag vilja lägga till fler funktioner, som att kunna satsa flera gånger per runda, och att skapa en bättre hantering av vinst- och förlustsituationer, dubbla och halvera och andra extra regler samt vinst statestik kring hand. Det skulle också vara kul att förbättra spelets grafiska utseende. Men överlag är jag ganska nöjd med min implementation och tycker att den fungerar bra som en enkel version av blackjack-spelet.
<br><br>
Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?
<br><br>
Jag trivs väldigt bra med att koda i Symfony, det är ett väldigt robust och flexibelt ramverk som gör det lätt att skapa avancerade webbapplikationer. Gillar start den inbyggda felhanteringen och att jag upplever det flexibelt.Efter att ha arbetat med Symfony ett tag har jag upptäckt att det finns många smarta verktyg och funktioner som kan underlätta arbetet och göra koden mer läsbar och strukturerad.
<br><br>
Vilken är din TIL för detta kmom?</p>
<br><br>

Under detta kursmoment har jag lärt mig hur man kan skapa objektorienterade lösningar och använder klasser för att organisera kod och funktioner. Det är viktigt att tänka på objektorientering för att skriva ren, modulär och återanvändbar kod. Klasserna kan användas för att gruppera relaterade funktioner och data, och det blir lättare att lägga till och ändra funktionalitet.
<br><br>
För att skapa kluriga klasser kan man tänka på att följa SOLID-principerna, särskilt öppen-stängd-principen (Open-Closed Principle) som betyder att en klass ska vara öppen för utökning men stängd för ändring. Detta innebär att man inte ska behöva ändra en klass för att lägga till funktionalitet, utan istället utöka den med en ny klass eller funktion som bygger vidare på den ursprungliga klassen.
<br><br>
För att skapa egen error hantering kan man använda verktyg som PHPStan som kan analysera koden för att hitta potentiella fel och problem. Man kan också skapa egna undantag (exceptions) som ger mer detaljerade felmeddelanden än de vanliga PHP-felen. Detta gör det enklare att felsöka och förbättra koden. Genom att skapa egna undantag kan man också bättre hantera fel som kan uppstå i en större applikation eller ramverk.Dock lekte jag inte mycket med detta

    <h4>Kmom04</h4

    <p>
    PHPUnit är en välkänd och respekterad PHP-testram som gör det möjligt för mig att testa min kod för att säkerställa att den fungerar korrekt. Några av fördelarna med att använda PHPUnit inkluderar att det hjälper mig att hitta buggar och problem i koden, ökar kvaliteten på koden och gör det lättare att underhålla och utveckla koden på lång sikt. Jag gillade hur det ser ut i mitt docs/coverage och kan enkelt hitta fel och det ser snyggt ut somsagt.
    </p>
    <br><br>

    <p>
    Fick till 75-80% vilken kan tyckas vara en ok start, men att ha en högre kodtäckning är alltid att föredra såklart. Det kan vara svårt att testa privata och skyddade funktioner vilket jag märkte samt saknade funktioner som kunde ta ut specifika fall eftersom jag använde min shuffle till korten osv,detta ledde till att jag inte kunde utan att fixa om/stoppa in flera funktioner(fick problem kring komplexitet i composer lint), fixen hade kunnat vara att fixa i card och eller blakjack en klass som hanterar att manuellt kunna skriva in kort en vill ha, detta kunde testa tie() samt annat som saknades till att nå 90% just nu avgör slumpen om tie() kommer triggas i min testning, men iaf , det är fortfarande möjligt att testa dem genom att använda reflektion och andra tekniker. 
    </p>
    <br><br>

    <p>
     Min kod var tillräckligt testbar men finns brister..
     De faktorer som  påverkade koden som testbar eller inte: Min kod är för stor och komplicerad kan det vara svårt att testa allt. Det kan också finnas svårigheter med att testa en kod som har många beroenden eller som är beroende av externa faktorer. För att förbättra min kods testbarhet kunde jag ha skapat mer lättförståelig kod genom att skapa tydligare kaller med en enda ansvarsområde, följa SOLID-principerna och undvika hårdkodade värden osv samt se ovan.
    </p>
    <br><br>
    <p>
    Har tankar till att skriva till bryta ut klassen BlackjackGame och och fixa det lite mer tydligare, Har somsagt velat fixa en specefic deal(valt kort) funktion men kommer aldrig dit, hade underlättat testningen, dock kan jag se att det hade fungerat vid testning om jag endast hade haft den.
    </p>
    <p>
    En vältestad kod är oftast ren och snygg. När du skriver enhetstester tvingas du att tänka på ditt kodkontrakt och hur dina metoder bör fungera. Detta leder till en mer organiserad kod som är lättare att underhålla och utveckla på lång sikt.
     </p>
    <br><br>
    <p> Min TIL (Today I Learned) för detta kmom är att enhetstester och testdriven utveckling kan hjälpa till att förbättra kvaliteten på din kod och göra den lättare att underhålla och utveckla på lång sikt. Det är också viktigt att prioritera kodtäckning och att skapa testbar kod för att uppnå detta.
    </p>

    <h4>Kmom05</h4
    <br><br>
    <h4>Gick det bra att jobba igenom övningen med Symfony och Doctrine? Något särskilt du tänkte/reagerade på under övningen?</h4>
    <br><br>
    <p>Ja, det gick bra att jobba igenom övningen med Symfony och Doctrine. En sak som jag märkte var att Symfony och Doctrine är kraftfulla verktyg som underlättar utvecklingen av webbapplikationer. De erbjuder många inbyggda funktioner och hjälper till att hantera olika aspekter av applikationen, inklusive databasåtkomst och modellhantering. Dessutom ger de en strukturerad och organiserad arbetsmetod genom att följa MVC-arkitekturmönstret. Jag gillar verkligen hur enkelt det var att skapa en struktur från scratch. Hur Doctrine skapade en bra "mall" mot webben.</p>
    <br><br>
    <h4>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?</h4>
    <br><br>
    <p>Under övningen byggde jag en enkel webbapplikation i min controller för att hantera böcker. Applikationen tillät användare att lägga till, visa, uppdatera och ta bort böcker från en databas. 
    När det gäller användargränssnittet valde jag att använda standard html/css men som jag tyckte slutade men en snygg look och enkelt att se och första. Jag använde även Twig-templatemotorn för att rendera vyer och skapa enkla användargränssnittskomponenter. Jag ville ha en ren och minimalistisk design för att fokusera på funktionaliteten snarare än det visuella.</p>
    <br><br>
    <h4>Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?</h4>
    <br><br>
    <p>Ja, det gick bra att jobba med ORM (Object-Relational Mapping) i CRUD-operationerna. Doctrine ORM gjorde det enkelt att arbeta med databasåtkomst genom att använda objekt istället för att skriva råa SQL-querys. Detta minskade komplexiteten och gjorde kodbasen mer läsbar och underhållbar.
    Jämfört med att arbeta med råa SQL-querys eller enklare databasabstraktioner, som till exempel PDO (PHP Data Objects), ger ORM en mer abstrakt och objektorienterad metod för att interagera med databasen. Det gör det enklare att hantera relationer mellan olika tabeller och erbjuder kraftfulla funktioner som till exempel datavalidering och automatisk generering av SQL-frågor.</p>
    <h4>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</h4>
    <br><br>
    <p>Min uppfattning om ORM är övervägande positiv. ORM-verktyg som Doctrine erbjuder en högre nivå av abstraktion och underlättar hanteringen av databasrelaterade uppgifter. Genom att använda ORM kan jag arbeta med databasen på ett objektorienterat sätt och undvika att behöva skriva råa SQL-frågor. Detta gör koden mer läsbar, underhållbar och minimerar risken för SQL-injektion.
    <br><br>
    Jämfört med att arbeta med råa SQL-frågor eller enklare databasabstraktioner som PDO/databaskursen, erbjuder ORM en rad fördelar. Det ger möjlighet att definiera och hantera relationer mellan tabeller på ett tydligt och enkelt sätt genom att använda objektorienterade koncept som associationer och navigering mellan entiteter. Det ger även möjlighet att använda datavalidering, automatisk generering av SQL-frågor och möjlighet till migrationshantering för att hantera databasförändringar över tiden.
    <br><br>
    En annan fördel med ORM är att det gör det enklare att byta databasbackend. Genom att använda en abstraktionsnivå kan man skriva applikationskod som är oberoende av den specifika databasen. Detta gör det möjligt att migrera applikationen till en annan databas utan att behöva ändra i själva koden.
    <br><br>
    Sammanfattningsvis är ORM ett kraftfullt verktyg för att hantera databasrelaterade uppgifter i applikationer. Det erbjuder en högre nivå av abstraktion, förenklar utvecklingen och minskar risken för vanliga problem som SQL-injektion. Det är dock viktigt att förstå hur ORM fungerar under huven och vara medveten om dess prestanda- och skalbarhetsaspekter i förhållande till specifika användningsfall.</p>
    <br><br>
    <h4>Vilken är din TIL för detta kmom?</h4>
    <p>Jag har även fått en introduktion till Doctrine ORM och dess förmåga att hantera databasrelaterade uppgifter på ett objektorienterat sätt. Genom att definiera entiteter och relationer kan man använda Doctrine för att kommunicera med databasen och utföra CRUD-operationer.</p>
    
    <h4>Kmom06</h4

        <h1>Hur uppfattade jag verktyget phpmetrics och fann jag några särskilda bitar mer värdefulla än andra?</h1>
        <br><br>
        <p>Jag uppfattade verktyget phpmetrics som användbart för att analysera och mäta kodkvalitet i PHP-projekt. Det erbjöd en omfattande uppsättning metriker och visuella representationer av kodens komplexitet och underhållbarhet. En särskilt värdefull bit för mig var "Maintainability Index", som gav en indikation på hur lätt eller svårt det skulle vara att underhålla koden över tid. Ju högre indexvärde desto bättre underhållbarhet, detta gav mig extra fokus och motivation att splitta koden till flera klasser</p>
        <br><br>

        <h1>Hur gick integrationen med Scrutinizer och vad är min första känsla av verktyget och dess badges?</h1><br><br>

        <p>Integrationen med Scrutinizer var relativt smidig. Det krävde att jag konfigurerade Scrutinizer att använda min versionshanteringsplattform och tillhandahöll nödvändiga autentiseringsuppgifter. Efter integrationen fick jag tillgång till Scrutinizers badges som visade kodkvalitet och kodtäckning på min projektsida. Min första känsla av verktyget och dess badges var positiv då de gav en snabb och översiktlig bedömning av projektets kodkvalitet och täckning.</p><br><br>
        
        <h1>Vad är min egen syn på kodkvalitet?</h1><br><br>

        <p>Jag anser att kodkvalitet är av avgörande betydelse för att upprätthålla ett hållbart och effektivt programvaruprojekt. Ren, läsbar och välskött kod är enklare att förstå, underhålla och utöka över tiden. Det minskar också risken för buggar och förbättrar samarbete inom utvecklingsteamet. Att följa bästa praxis och använda väldefinierade kodningsstandarder är viktigt för att uppnå hög kodkvalitet och att somsagt kunna sammarbeta och navigera sin kod och beskriva den till andra.</p>
        
        <br><br>
        <h1>Tror jag att man kan påvisa kodkvalitet med badges eller vad tror jag?</h1>
        
        <br><br>
        
        <p>Jag tror att badges kan ge en indikation på kodkvalitet, men de kan inte påvisa det fullständigt. Badges, som exempelvis de som tillhandahålls av verktyg som Scrutinizer, kan ge en snabb visuell representation av kodkvalitet och kodtäckning. De ger en överblick över projektets status och kan fungera som incitament för att sträva efter bättre kodkvalitet. Men det är viktigt att komma ihåg att badges är en förenklad återgivning och inte ersätter en noggrann kodgranskning och analyser av verktyg.</p>
        <br><br>
        <h1>Vad är min "TIL" för detta kursmoment?</h1>
        <br><br>
        <p>Mitt "TIL" (Today I Learned) för detta kursmoment var att få en djupare förståelse för olika verktyg och metoder för att mäta och förbättra kodkvalitet. Jag fick också praktisk erfarenhet av att integrera och använda verktyg som phpmetrics och Scrutinizer i mitt eget projekt. Det var en värdefull erfarenhet att se hur dessa verktyg kan bidra till att identifiera områden för förbättring och ge en objektiv bedömning av kodkvalitet och täckning.

        Jag lärde mig också att använda metriker som Maintainability Index för att bedöma kodens underhållbarhet och identifiera potentiella problemområden. Genom att analysera och tolka dessa metriker kan jag fatta informerade beslut om att förbättra kodens struktur och läsbarhet.

        Att använda badges för att visa kodkvalitet och kodtäckning var också en ny erfarenhet för mig. Det gav en visuell representation av projektets status och gjorde det enkelt att kommunicera kodkvaliteten till andra i teamet eller till externa intressenter.

        Sammanfattningsvis har detta kursmoment gett mig en bredare förståelse för betydelsen av kodkvalitet och olika verktyg och metoder för att uppnå och mäta det. Det har inspirerat mig att fortsätta sträva efter renare och mer underhållbar kod och att använda lämpliga verktyg och metoder för att uppnå detta mål.



    <h1>Kmom010</h1>


    <h1>Krav 1 2 3 4</h1>

    <p>För att uppfylla krav 1 har jag skapat en landningssida ("/proj") som syns i navbaren på report-sidan. Jag har också skapat en separat navbar för projektet som innehåller länkarna för projektet.<br><br>

    För att uppfylla krav 2 har jag implementerat mitt projekt på webbplatsen under "/proj". Jag har valt ett fokus för mitt projekt och har skapat en sida ("/proj/about") som ger en kort introduktion till projektet och vad det handlar om.<br><br>

    För att uppfylla krav 3 har jag modifierat utseendet på webbplatsen för att skilja det från report-sidan. Jag har skapat en "ny" stylesheet eller modifierat den befintliga för att ändra färg, typsnitt och utseende på header och footer.
    <br><br>

    För att uppfylla krav 4 har jag skapat ett JSON API till mitt projekt och presenterat det på sidan "/proj/api". API:et har 5 olika JSON routes, varav minst en är en POST route. Jag har också lagt till länkar/knappar på sidan för att testa API:et.<br><br>

    I min kod har jag använt Symfony-komponenter och doctrine för att hantera routing, databasåtkomst och rendera sidor. Jag har också skapat olika controller-metoder för varje sida och har använt olika repository-klasser för att hämta och hantera data från databasen. Dessutom har jag skapat hjälparklasser för att formatera och manipulera data för visualisering. Jag har använt Twig-templatemotor för att rendera HTML-sidor och har skickat data till dessa sidor via render-metoden.

    Sammanfattningsvis har jag implementerat en webbplats som uppfyller de angivna kraven genom att skapa landningssida, implementera projektet, modifiera utseendet, och skapa ett JSON API.</p>



    <h1>Går igenom koden och förklara vad varje del gör i mer detalj.</h1>
    <br><br>

    Kontrollern är definierad som projectController och ärver från AbstractController i Symfony. Detta ger kontrollern tillgång till olika hjälpfunktioner och egenskaper som förenklar hanteringen av HTTP-anrop och renderingen av mallar.<br><br>

    I konstruktorn för projectController injiceras flera beroenden via beroendeinjektion (dependency injection), inklusive EntityManagerInterface och några hjälpklasser som EffektAvCovid19Helper, HelperBoende och UnemployementHelper. Dessa beroenden används senare i kontrollerns metoder.<br><br>

    Metoden vizualizer hanterar GET-anropet till /proj/vizualizer-routen och tar emot ett argument av typen EffektAvCovid19Repository. Inuti metoden rensar den befintliga datatabellen (EffektAvCovid19) och skapar en ny post i tabellen med hjälp av EffektAvCovid19Helper-klassen. Därefter hämtar den alla poster från tabellen och formatterar datan med hjälp av EffektAvCovid19Helper. Den renderar sedan en mall (show_all.statistics.html.twig) med den formaterade datan.

    Metoderna boendevizualizer och boendevizualizersecond fungerar på liknande sätt som vizualizer, men de arbetar med BoendeRepository och HelperBoende för att hantera boendedata och rendera andra mallar (show_all.statistics2.html.twig).
    <br><br>
    
    <h1>Mer kortfattat teknisk beskrivning om resten om projController:</h1>
    <br><br>
    
    <p>Route: '/proj/unemployement'
    <br><br>

    Metod: GET
    Funktion: Hämtar statistik om arbetslöshet från databasen och visar den i en HTML-mall.
    Åtgärder:
    Raderar alla befintliga poster i tabellen 'Unemployement' i databasen.
    Skapar en array med arbetslöshetsdata.
    Skapar en instans av hjälparklassen 'UnemployementHelper'.
    Loopar igenom arbetslöshetsdatan och skapar och sparar nya 'Unemployement'-entiteter i databasen.
    Hämtar data från databasen.
    Formaterar datan med hjälp av hjälparklassen 'UnemployementHelper'.
    Skickar tillbaka formatterad data till klienten och renderar den i en HTML-mall.
    <br><br>

    Route: '/proj/api/effekt_av_covid19'
    <br><br>
    Metod: GET
    Funktion: Hämtar data om effekterna av Covid-19 från databasen och returnerar den som en JSON-respons.
    Åtgärder:
    Raderar alla befintliga poster i tabellen 'EffektAvCovid19' i databasen.
    Skapar en ny 'EffektAvCovid19'-entitet och sparar den i databasen.
    Hämtar data från databasen.
    Formaterar datan med hjälp av en hjälparklass.
    Skickar formatterad data som JSON-respons till klienten.
    <br><br>
    Route: '/proj/api/boende'
    <br><br>
    Metod: GET
    Funktion: Hämtar boendedata från databasen och returnerar den som en JSON-respons.
    Åtgärder:
    Skapar en instans av hjälparklassen 'HelperBoende'.
    Anropar en annan metod 'boendevizualizersecond' för att fylla tabellen med data.
    Hämtar data från databasen.
    Formaterar datan med hjälp av hjälparklassen 'HelperBoende'.
    Skickar formatterad data som JSON-respons till klienten.

    <br><br>
    Route: '/proj/api/unemployment'
    <br><br>
    Metod: GET
    Funktion: Hämtar arbetslöshetsdata från databasen och returnerar den som en JSON-respons.
    Åtgärder:
    Skapar en instans av hjälparklassen 'UnemployementHelper'.
    Anropar en annan metod 'unemployementizualizersecond' för att fylla tabellen med data.
    Hämtar data från databasen.
    Formaterar datan med hjälp av hjälparklassen 'UnemployementHelper'.
    Skickar formatterad data som JSON-respons till klienten.
    <br><br>
    Route: '/proj/api/covid19/{total_deaths}'
    <br><br>
    Metod: GET
    Funktion: Hämtar data om Covid-19-dödsfall baserat på det totala antalet dödsfall och returnerar det som en JSON-respons.
    Åtgärder:
    Raderar alla befintliga poster i tabellen 'EffektAvCovid19' i databasen.
    Skapar en ny 'EffektAvCovid19'-entitet och sparar den i databasen.
    Hämtar data från databasen baserat på det totala antalet dödsfall.
    Skapar en JSON-respons med information om antalet dödsfall och skickar tillbaka den till klienten.
     <br><br>
    Route: '/proj/api/covid19Female/{female_deaths}'
    <br><br>
    Metod: GET
    Funktion: Hämtar data om Covid-19-dödsfall bland kvinnor baserat på antalet kvinnliga dödsfall och returnerar det som en JSON-respons.
    Åtgärder:
    Raderar alla befintliga poster i tabellen 'EffektAvCovid19' i databasen.
    Skapar en ny 'EffektAvCovid19'-entitet och sparar den i databasen.
    Hämtar data från databasen baserat på antalet kvinnliga dödsfall.
    Skapar en JSON-respons med information om antalet dödsfall bland kvinnor och skickar tillbaka den till klienten.
    <br><br>
    Route: '/proj/api/boende/{Vecka}'
    <br><br>
    Metod: GET
    Funktion: Hämtar boendedata från databasen baserat på en specifik vecka och returnerar det som en JSON-respons.
    Åtgärder:
    Skapar en instans av hjälparklassen 'HelperBoende'.
    Anropar en annan metod 'boendevizualizersecond' för att fylla tabellen med data.
    Hämtar data från databasen baserat på en specifik vecka.
    Skapar en JSON-respons med boendedata för den specifika veckan och skickar tillbaka den till klienten.
    <br><br>
    Route: '/proj/api/boendeAgeRange/{ageRange}'
    <br><br>
    Metod: GET
    Funktion: Hämtar arbetslöshetsdata från databasen baserat på en specifik åldersgrupp och returnerar det som en JSON-respons.
    Åtgärder:
    Skapar en instans av hjälparklassen 'UnemployementHelper'.
    Anropar en annan metod 'unemployementizualizersecond' för att fylla tabellen med data.
    Hämtar data från databasen baserat på en specifik åldersgrupp.
    Skapar en JSON-respons med arbetslöshetsdata för den specifika åldersgruppen och skickar tillbaka den till klienten.
    <br><br>
    Route: '/proj/reset'
    <br><br>
    Metod: GET
    Funktion: Återställer databasen genom att ta bort alla poster i tabellerna 'EffektAvCovid19', 'Boende' och 'Unemployement'.
    Åtgärder:
    Skapar en anslutning till databasen och erhåller databasplattformen.
    Använder databasplattformen för att utföra SQL-kommandon för att rensa tabellerna 'EffektAvCovid19', 'Boende' och 'Unemployement'.
    Returnerar en omdirigering till huvudsidan 'proj'.
    Dessa rutter används för att hantera olika begäranden och svar inom en webbapplikation som tycks vara relaterade till statistik om arbetslöshet, boende och Covid-19-effekter. Det finns också åtgärder som hanterar rensning och återställning av databasen. Notera att det är svårt att ge en heltäckande förklaring utan ytterligare information om andra hjälparklasser och eventuella relationer till databasen och andra delar av koden.</p>

    <br><br>

    <h1>Twig och presentation, visualisering</h1>
    <br><br>

    
    <p>Inom de olika twigsen skriver jag en del "findings" och lite av mina "conlussions" kring datan jag hittade samt citerar till stasticmyndigheten och har links till oringal excell filerna.
    <br><br>
    
    Den formaterade datan visas sedan i ett rutnätsformat med hjälp av en loop över data-variabeln. Varje objekt representerar ett fält och fälten visas med sina motsvarande data.
    I javascripts-blocket är JavaScript-koden inkapslad. Data hämtas från servern med hjälp av Twig och fyller data- och label-arrayerna. Sedan skapas en linjediagram med hjälp av Chart.js-biblioteket. Diagrammet visar data för varje år och använder olika färger för varje dataset.
    <br><br>
    Genom att presentera data med hjälp av ORM (Object-Relational Mapping) och utnyttja Chart.js för visualisering får du följande fördelar:

    Datahantering: Genom att använda ORM kan du enkelt hämta och manipulera data från databasen, vilket underlättar att extrahera och presentera den önskade informationen.

    Strukturerad presentation: Genom att organisera datan i ett rutnätsformat och använda HTML och CSS kan du presentera informationen på ett strukturerat och visuellt tilltalande sätt.

    Interaktiva visualiseringar: Chart.js erbjuder interaktiva och anpassningsbara diagram som förbättrar upplevelsen av att visualisera data. Användare kan interagera med diagrammet, zooma in/ut och svepa över datapunkter för att se ytterligare detaljer.

    Sammanhållen webbutveckling: Genom att kombinera olika tekniker som ORM, HTML/CSS och JavaScript-bibliot</p>

    <h1>Om projektet i helhet samt avslutande text</h1>
    <br><br>
    <p>
    Att arbeta med statistik och integrera flera tekniker samtidigt i projektet var definitivt klurigt, men samtidigt mycket givande och intressant. Att presentera data på ett visuellt sätt och analysera statistik personligen var en utmaning som krävde noggrannhet och precision. Genom att kombinera olika tekniker som PHP,ORM, HTML/CSS och JavaScript, fick jag möjlighet att utforska och lära mig nya sätt att hantera och visualisera data.<br><br> 
    <br><br> 
    Extra glad var jag med
    Klassen HelperBoende som användes för att sätta och hämta data i en Boende-entitet. Den har två huvudmetoder: setData() och getData().
    Metoden setData() tar emot en array med data och en instans av Boende-entiteten. Den sätter sedan data i entitetens olika attribut baserat på arrayens innehåll. Till exempel sätts veckonummer i attributet 'Vecka', 2016 års data i attributet 'Twthousandsixteen', och så vidare.
    Metoden getData() tar emot en instans av Boende-entiteten och returnerar en array med data. Denna metod hämtar värdet från varje attribut i entiteten och placerar det i en associerad array där nycklarna representerar olika år.<br><br> 

    Det var fördelaktigt att använda denna klass för både Boende-data och Boende-data utan speciellt boende istället för att skapa två separata tabeller med olika klasser. Det sparade tid och minskade komplexiteten i koden. Genom att använda HelperBoende-klassen kunde jag enkelt hantera och manipulera data i Boende-entiteten på ett strukturerat sätt.

    Sammanfattningsvis var HelperBoende en bra och användbar komponent i projektet. Den underlättade datahanteringen och bidrog till en mer effektiv och läsbar kodbas.
    <br><br> 
    Under projektets gång stötte jag på vissa hinder och strul. En utmaning var att anpassa CSS-stilen och skapa en separat mapp för att lagra och använda egna stilfiler istället för att förlita mig på inbyggda tillgångar. Dessutom, när jag körde "npm run build" för att slå samman mina separata filer till en, ställdes jag inför svårigheten att skapa nya klasser för att matcha projektets design och layout. Annat var att fixa till i diverse config filer till att fixa till phpunit och metrics etc men lyckades tillslut med, Clona repository var med lite struligt men var mycket givande i slutet att lyckas starta en kopia via live servern!<br><br>

    Även om projektet var utmanande och krävde tid och ansträngning för att lösa dessa problem, var det en givande upplevelse. Jag fick möjlighet att utveckla mina färdigheter inom webbutveckling och tillämpa dem på ett verkligt scenario. Trots vissa hinder gick projektet relativt smidigt, och jag kunde slutföra det inom rimlig tid samt var tydligt att jag kunde ta kunskap utefter tidigare moment!.<br><br>

    Jag anser att detta projekt var en bra och rimlig uppgift för kursen. Det gav mig möjlighet att tillämpa de kunskaper och tekniker jag lärt mig under kursens gång och utmana mig själv i att skapa en dynamisk och interaktiv webbapplikation. Det var också en bra övning i att hantera och presentera statistik på ett meningsfullt sätt.<br><br>

    När det gäller kursen i sin helhet är jag överlag nöjd. Materialet var välstrukturerat och förklarade koncepten på ett tydligt sätt. Handledningen var till hjälp och svarade på mina frågor. Jag skulle rekommendera kursen till mina vänner och kollegor som är intresserade av att lära sig webbutveckling med fokus på MVC-arkitekturen. På en skala från 1 till 10 skulle jag ge kursen betyget 8. Det fanns utrymme för förbättringar, särskilt i att tillhandahålla mer beksrivning och praktiska exempel kring configuering,fler design alternativ,cloning av git, men övergripande sett var det en givande och lärorik kurs</p><br><br>
    


{% endblock %}